<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>final_project documentation &#8212; final_project 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PyClassify Module Documentation" href="pyclassify.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="final-project-documentation">
<h1>final_project documentation<a class="headerlink" href="#final-project-documentation" title="Link to this heading"></a></h1>
<p>Welcome to the documentation for the final project of the course in Development Tools for Scientific Computing.
We are currently working on the project and on the documentation.
Stay tuned!</p>
<p>Recall that the documentation is written following
<a class="reference external" href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html">reStructuredText</a></p>
</section>
<section id="table-of-contents">
<h1>Table of Contents<a class="headerlink" href="#table-of-contents" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html">PyClassify Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify">Functions:</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.Lanczos_PRO"><code class="docutils literal notranslate"><span class="pre">Lanczos_PRO()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.QR_method"><code class="docutils literal notranslate"><span class="pre">QR_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.eigenvalues_cp"><code class="docutils literal notranslate"><span class="pre">eigenvalues_cp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.eigenvalues_np"><code class="docutils literal notranslate"><span class="pre">eigenvalues_np()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.eigenvalues_sp"><code class="docutils literal notranslate"><span class="pre">eigenvalues_sp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.power_method"><code class="docutils literal notranslate"><span class="pre">power_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.power_method_cp"><code class="docutils literal notranslate"><span class="pre">power_method_cp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.power_method_numba"><code class="docutils literal notranslate"><span class="pre">power_method_numba()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify.utils">Submodule: utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.check_square_matrix"><code class="docutils literal notranslate"><span class="pre">check_square_matrix()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.check_symm_square"><code class="docutils literal notranslate"><span class="pre">check_symm_square()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.make_symmetric"><code class="docutils literal notranslate"><span class="pre">make_symmetric()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.power_method_numba_helper"><code class="docutils literal notranslate"><span class="pre">power_method_numba_helper()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.read_config"><code class="docutils literal notranslate"><span class="pre">read_config()</span></code></a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="module-documentation">
<h1>Module Documentation<a class="headerlink" href="#module-documentation" title="Link to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">Lanczos_PRO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">toll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64(1.4901161193847656e-08)</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform the Lanczos algorithm for symmetric matrices.</p>
<p>This function computes an orthogonal matrix Q and tridiagonal matrix T such that A is approximately
equal to Q * T * Q.T, where A is a symmetric matrix. The algorithm is useful for finding a few
eigenvalues and eigenvectors of large symmetric matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A symmetric square matrix of size n x n.</p></li>
<li><p><strong>q</strong> (<em>np.ndarray</em>) – Initial vector of size n.</p></li>
<li><p><strong>m</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of eigenvalues to compute. Must be less than or equal to n.
If None, defaults to the size of A.</p></li>
<li><p><strong>toll</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for orthogonality checks (default is sqrt(machine epsilon)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple (Q, alpha, beta) where:</dt><dd><ul class="simple">
<li><p>Q (np.ndarray): Orthogonal matrix of size n x m.</p></li>
<li><p>alpha (np.ndarray): Vector of size m containing the diagonal elements of the tridiagonal matrix.</p></li>
<li><p>beta (np.ndarray): Vector of size m-1 containing the off-diagonal elements of the tridiagonal matrix.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the input matrix A is not square or if m is greater than the size of A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">QR_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A_copy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the eigenvalues of a tridiagonal matrix using the QR algorithm.</p>
<p>This function uses the QR decomposition method to iteratively compute the eigenvalues of a given tridiagonal matrix.
The QR algorithm is an iterative method that computes the eigenvalues of a matrix by decomposing it into a product
of an orthogonal matrix Q and an upper triangular matrix R, and then updating the matrix as the product of R and Q.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A_copy</strong> (<em>np.ndarray</em>) – Atridiagonal matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the off-diagonal elements (default is 1e-10).</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 100).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple (eigenvalues, Q) where:</dt><dd><ul class="simple">
<li><p>eigenvalues (np.ndarray): An array containing the eigenvalues of the matrix <cite>A_copy</cite>.</p></li>
<li><p>Q (np.ndarray): The orthogonal matrix Q from the final QR decomposition.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the input matrix A_copy is not square.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the eigenvalues of a sparse matrix using CuPy’s <cite>eigsh</cite> function.</p>
<p>This function checks if the input matrix is square and symmetric, then computes its eigenvalues using
CuPy’s sparse linear algebra solvers. It uses <cite>eigsh</cite> for more efficient computation.
Remark that the eigsh function in this case does not allow to compute <em>all</em> the eigenvalues, but only a number
m&lt;n, so here just a reduced portion is computed (starting form the ones which are greater in magnitude).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>cpsp.spmatrix</em>) – A square sparse matrix whose eigenvalues are to be computed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the sparse matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a CuPy sparse symmetric matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_np</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the eigenvalues of a square matrix using NumPy’s <cite>eig</cite> or <cite>eigh</cite> function.</p>
<p>This function checks if the input matrix is square (and is actually a matrix) using ‘check_square_matrix’, and then computes its eigenvalues.
If the matrix is symmetric, it uses <cite>eigh</cite> (which is more efficient for symmetric matrices).
Otherwise, it uses <cite>eig</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigh</cite> for
faster computation. If False, uses <cite>eig</cite> for general matrices
(default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_sp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the eigenvalues of a sparse matrix using SciPy’s <cite>eigsh</cite> or <cite>eigs</cite> function.</p>
<p>This function checks if the input matrix is square, then computes its eigenvalues using
SciPy’s sparse linear algebra solvers. For symmetric matrices, it uses <cite>eigsh</cite> for
more efficient computation. For non-symmetric matrices, it uses <cite>eigs</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>sp.spmatrix</em>) – A square sparse matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigsh</cite>.
If False, uses <cite>eigs</cite> for general matrices (default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the sparse matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the dominant eigenvalue of a square matrix using the power method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em><em> or </em><em>cpsp.spmatrix</em>) – A square matrix whose dominant eigenvalue is to be computed.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between iterations
(default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix <cite>A</cite>, computed as the Rayleigh quotient x &#64; A &#64; x.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the dominant eigenvalue of a square matrix using the power method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>cp.spmatrix</em>) – A square matrix whose dominant eigenvalue is to be computed.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between iterations
(default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>cp.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix <cite>A</cite>, computed as the Rayleigh quotient x &#64; A &#64; x.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method_numba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the dominant eigenvalue of a matrix using the power method, with Numba optimization.</p>
<p>This function wraps the <cite>power_method</cite> function and applies Numba’s Just-In-Time (JIT) compilation
to optimize the performance of the power method for large matrices. The function leverages the
<cite>power_method_numba_helper</cite> function for the actual computation. The reason for that is the following: profiling
directly a function decorated with &#64;numba.jit does not actually keep track of the calls and execution time due to
numba technicalities. Therefore, the helper function is profiled instead.
Remark that numba does not support scipy sparse matrices, so the input matrix must be a NumPy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix whose dominant eigenvalue is to be computed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">final_project</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html">PyClassify Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify">Functions:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify.utils">Submodule: utils</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
      <li>Next: <a href="pyclassify.html" title="next chapter">PyClassify Module Documentation</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Gaspare Li Causi, Lorenzo Tomada.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>