<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>final_project documentation &#8212; final_project 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PyClassify Module Documentation" href="pyclassify.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="final-project-documentation">
<h1>final_project documentation<a class="headerlink" href="#final-project-documentation" title="Link to this heading"></a></h1>
<p>Welcome to the documentation for the final project of the course in Development Tools for Scientific Computing.
Our goal is to compute an efficient solver for eigenvalue problems.</p>
<p>For theoretical details, please check the file docs/Documentation.ipynb
To install the package, please read the README.md file.</p>
</section>
<section id="table-of-contents">
<h1>Table of Contents<a class="headerlink" href="#table-of-contents" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html">PyClassify Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify">Functions:</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.EigenSolver"><code class="docutils literal notranslate"><span class="pre">EigenSolver</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.Lanczos_PRO"><code class="docutils literal notranslate"><span class="pre">Lanczos_PRO()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.eigenvalues_np"><code class="docutils literal notranslate"><span class="pre">eigenvalues_np()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.eigenvalues_sp"><code class="docutils literal notranslate"><span class="pre">eigenvalues_sp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.power_method"><code class="docutils literal notranslate"><span class="pre">power_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.power_method_numba"><code class="docutils literal notranslate"><span class="pre">power_method_numba()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify.utils">Submodule: utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.check_square_matrix"><code class="docutils literal notranslate"><span class="pre">check_square_matrix()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.check_symm_square"><code class="docutils literal notranslate"><span class="pre">check_symm_square()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.make_symmetric"><code class="docutils literal notranslate"><span class="pre">make_symmetric()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.max_iteration_warning"><code class="docutils literal notranslate"><span class="pre">max_iteration_warning()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.poisson_2d_structure"><code class="docutils literal notranslate"><span class="pre">poisson_2d_structure()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.profile_numpy_eigvals"><code class="docutils literal notranslate"><span class="pre">profile_numpy_eigvals()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.profile_scipy_eigvals"><code class="docutils literal notranslate"><span class="pre">profile_scipy_eigvals()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.utils.read_config"><code class="docutils literal notranslate"><span class="pre">read_config()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#submodule-helpers-secular">Submodule: helpers_secular</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.zero_finder.bisection"><code class="docutils literal notranslate"><span class="pre">bisection()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.zero_finder.compute_Psi"><code class="docutils literal notranslate"><span class="pre">compute_Psi()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.zero_finder.compute_outer_zero"><code class="docutils literal notranslate"><span class="pre">compute_outer_zero()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.zero_finder.find_root"><code class="docutils literal notranslate"><span class="pre">find_root()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pyclassify.html#pyclassify.zero_finder.secular_solver_python"><code class="docutils literal notranslate"><span class="pre">secular_solver_python()</span></code></a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="module-documentation">
<h1>Module Documentation<a class="headerlink" href="#module-documentation" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">EigenSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_deflation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class solving the eigenvalue problem for a given symmetric matrix.</p>
<p>Two different building blocks are present: Lanczos_PRO (used to transform the matrix to
a tridiagonal one), and another function written in C++. The latter can be either
Eigen_value_calculator (if the user is only interested in the computation of the eigenvalues)
or QR_algorithm, if eigenvectors are needed as well.</p>
<p>We refer the interested reader to their implementation in C++ for further details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">compute_eigenval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute (only) the eigenvalues of a symmetric triangular matrix, passed as argument in the form of diagonal and
off-diagonal.</p>
<p>This function relies on the Eigen_value_calculator function, written in C++.
:param diag: Diagonal of the matrix. Default value is None. If no value is passed, the one used</p>
<blockquote>
<div><p>is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>off_diag</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Off-iagonal of the matrix. Default value is None. If no value is passed, the one
used is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an np.array containing the eigenvalues of the matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is a mismatch between the diagonal and off diagonal size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the eigenvalues and eigenvectors of a symmetric triangular matrix, passed as argument in the form of
diagonal and off-diagonal.</p>
<p>This function relies on the QR_algorithm function, written in C++.
:param diag: Diagonal of the matrix. Default value is None. If no value is passed, the one used</p>
<blockquote>
<div><p>is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>off_diag</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Off-iagonal of the matrix. Default value is None. If no value is passed, the one
used is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple containing two arrays, the eigenvalues and the eigenvectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is a mismatch between the diagonal and off diagonal size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">initial_guess</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">Lanczos_PRO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64(1.4901161193847656e-08)</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform the Lanczos algorithm for symmetric matrices.</p>
<p>This function computes an orthogonal matrix Q and tridiagonal matrix T such that
.. math:: <cite>A approx Q T Q^T,</cite>
where A is a symmetric matrix. The algorithm is useful for finding a few eigenvalues and eigenvectors
of large symmetric matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A symmetric square matrix of size n x n.</p></li>
<li><p><strong>q</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial vector of size n. Default value is None (a random one is created).</p></li>
<li><p><strong>m</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of eigenvalues to compute. Must be less than or equal to n.
If None, defaults to the size of A.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for orthogonality checks (default is sqrt(machine epsilon)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple (Q, alpha, beta) where:</dt><dd><ul class="simple">
<li><p>Q (np.ndarray): Orthogonal matrix of size n x m.</p></li>
<li><p>alpha (np.ndarray): Vector of size m containing the diagonal elements of the tridiagonal matrix.</p></li>
<li><p>beta (np.ndarray): Vector of size m-1 containing the off-diagonal elements of the tridiagonal matrix.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns or the matrix is not symmetric or it m is
    greater than the size of A.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_np</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Wrapper for the np eigenvalue solver. This function is only used in tests for better readability.
Compute the eigenvalues of a square matrix using NumPy’s <cite>eig</cite> or <cite>eigh</cite> function.</p>
<p>This function checks if the input matrix is square (and is actually a matrix) using
‘check_square_matrix’, and then computes its eigenvalues.</p>
<p>If the matrix is symmetric, it uses <cite>eigh</cite> (which is more efficient for symmetric matrices).
Otherwise, it uses <cite>eig</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigh</cite> for
faster computation. If False, uses <cite>eig</cite> for general matrices
(default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_sp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the eigenvalues of a sparse matrix using SciPy’s <cite>eigsh</cite> or <cite>eigs</cite> function.</p>
<p>This function checks if the input matrix is square, then computes its eigenvalues using
SciPy’s sparse linear algebra solvers. For symmetric matrices, it uses <cite>eigsh</cite> for
more efficient computation. For non-symmetric matrices, it uses <cite>eigs</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>sp.spmatrix</em>) – A square sparse matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigsh</cite>.
If False, uses <cite>eigs</cite> for general matrices (default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the sparse matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the dominant eigenvalue of a square matrix using the power method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em><em> or </em><em>cpsp.spmatrix</em>) – A square matrix whose dominant eigenvalue is to be computed.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between iterations
(default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix <cite>A</cite>, computed as the Rayleigh quotient x &#64; A &#64; x.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method_numba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the dominant eigenvalue of a matrix using the power method, with Numba optimization.</p>
<p>This function and applies Numba’s Just-In-Time (JIT) compilation to optimize the performance of the
power method for large matrices.</p>
<p>Remark that numba does not support scipy sparse matrices, so the input matrix must be a NumPy array.
he function is optimized with Numba using the ‘njit’ decorator with nogil and parallel options.
We have re-written the code due to the fact that using numba we cannot use the helper function check_square_matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between
iterations (default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix A.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the input matrix A is not square. The check is not done using ‘check_square_matrix’
    because of numba technicalities.</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">final_project</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html">PyClassify Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify">Functions:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#module-pyclassify.utils">Submodule: utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyclassify.html#submodule-helpers-secular">Submodule: helpers_secular</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
      <li>Next: <a href="pyclassify.html" title="next chapter">PyClassify Module Documentation</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Gaspare Li Causi, Lorenzo Tomada.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>