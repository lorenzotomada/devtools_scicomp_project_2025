<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PyClassify Module Documentation &#8212; final_project 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="final_project documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pyclassify-module-documentation">
<h1>PyClassify Module Documentation<a class="headerlink" href="#pyclassify-module-documentation" title="Link to this heading"></a></h1>
<p>This module contains all the functions for the PyClassify package.</p>
</section>
<section id="module-pyclassify">
<span id="functions"></span><h1>Functions:<a class="headerlink" href="#module-pyclassify" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pyclassify.EigenSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">EigenSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_deflation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class solving the eigenvalue problem for a given symmetric matrix.</p>
<p>Two different building blocks are present: Lanczos_PRO (used to transform the matrix to
a tridiagonal one), and another function written in C++. The latter can be either
Eigen_value_calculator (if the user is only interested in the computation of the eigenvalues)
or QR_algorithm, if eigenvectors are needed as well.</p>
<p>We refer the interested reader to their implementation in C++ for further details.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyclassify.EigenSolver.compute_eigenval">
<span class="sig-name descname"><span class="pre">compute_eigenval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver.compute_eigenval" title="Link to this definition"></a></dt>
<dd><p>Compute (only) the eigenvalues of a symmetric triangular matrix, passed as argument in the form of diagonal and
off-diagonal.</p>
<p>This function relies on the Eigen_value_calculator function, written in C++.
:param diag: Diagonal of the matrix. Default value is None. If no value is passed, the one used</p>
<blockquote>
<div><p>is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>off_diag</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Off-iagonal of the matrix. Default value is None. If no value is passed, the one
used is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an np.array containing the eigenvalues of the matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is a mismatch between the diagonal and off diagonal size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyclassify.EigenSolver.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver.eig" title="Link to this definition"></a></dt>
<dd><p>Compute the eigenvalues and eigenvectors of a symmetric triangular matrix, passed as argument in the form of
diagonal and off-diagonal.</p>
<p>This function relies on the QR_algorithm function, written in C++.
:param diag: Diagonal of the matrix. Default value is None. If no value is passed, the one used</p>
<blockquote>
<div><p>is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>off_diag</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Off-iagonal of the matrix. Default value is None. If no value is passed, the one
used is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple containing two arrays, the eigenvalues and the eigenvectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is a mismatch between the diagonal and off diagonal size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyclassify.EigenSolver.initial_guess">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">initial_guess</span></span><a class="headerlink" href="#pyclassify.EigenSolver.initial_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.Lanczos_PRO">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">Lanczos_PRO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64(1.4901161193847656e-08)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.Lanczos_PRO" title="Link to this definition"></a></dt>
<dd><p>Perform the Lanczos algorithm for symmetric matrices.</p>
<p>This function computes an orthogonal matrix Q and tridiagonal matrix T such that
.. math:: <cite>A approx Q T Q^T,</cite>
where A is a symmetric matrix. The algorithm is useful for finding a few eigenvalues and eigenvectors
of large symmetric matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A symmetric square matrix of size n x n.</p></li>
<li><p><strong>q</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial vector of size n. Default value is None (a random one is created).</p></li>
<li><p><strong>m</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of eigenvalues to compute. Must be less than or equal to n.
If None, defaults to the size of A.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for orthogonality checks (default is sqrt(machine epsilon)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple (Q, alpha, beta) where:</dt><dd><ul class="simple">
<li><p>Q (np.ndarray): Orthogonal matrix of size n x m.</p></li>
<li><p>alpha (np.ndarray): Vector of size m containing the diagonal elements of the tridiagonal matrix.</p></li>
<li><p>beta (np.ndarray): Vector of size m-1 containing the off-diagonal elements of the tridiagonal matrix.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns or the matrix is not symmetric or it m is
    greater than the size of A.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.eigenvalues_np">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_np</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.eigenvalues_np" title="Link to this definition"></a></dt>
<dd><p>Wrapper for the np eigenvalue solver. This function is only used in tests for better readability.
Compute the eigenvalues of a square matrix using NumPy’s <cite>eig</cite> or <cite>eigh</cite> function.</p>
<p>This function checks if the input matrix is square (and is actually a matrix) using
‘check_square_matrix’, and then computes its eigenvalues.</p>
<p>If the matrix is symmetric, it uses <cite>eigh</cite> (which is more efficient for symmetric matrices).
Otherwise, it uses <cite>eig</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigh</cite> for
faster computation. If False, uses <cite>eig</cite> for general matrices
(default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.eigenvalues_sp">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_sp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.eigenvalues_sp" title="Link to this definition"></a></dt>
<dd><p>Compute the eigenvalues of a sparse matrix using SciPy’s <cite>eigsh</cite> or <cite>eigs</cite> function.</p>
<p>This function checks if the input matrix is square, then computes its eigenvalues using
SciPy’s sparse linear algebra solvers. For symmetric matrices, it uses <cite>eigsh</cite> for
more efficient computation. For non-symmetric matrices, it uses <cite>eigs</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>sp.spmatrix</em>) – A square sparse matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigsh</cite>.
If False, uses <cite>eigs</cite> for general matrices (default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the sparse matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.power_method">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.power_method" title="Link to this definition"></a></dt>
<dd><p>Compute the dominant eigenvalue of a square matrix using the power method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em><em> or </em><em>cpsp.spmatrix</em>) – A square matrix whose dominant eigenvalue is to be computed.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between iterations
(default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix <cite>A</cite>, computed as the Rayleigh quotient x &#64; A &#64; x.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.power_method_numba">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method_numba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.power_method_numba" title="Link to this definition"></a></dt>
<dd><p>Compute the dominant eigenvalue of a matrix using the power method, with Numba optimization.</p>
<p>This function and applies Numba’s Just-In-Time (JIT) compilation to optimize the performance of the
power method for large matrices.</p>
<p>Remark that numba does not support scipy sparse matrices, so the input matrix must be a NumPy array.
he function is optimized with Numba using the ‘njit’ decorator with nogil and parallel options.
We have re-written the code due to the fact that using numba we cannot use the helper function check_square_matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between
iterations (default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix A.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the input matrix A is not square. The check is not done using ‘check_square_matrix’
    because of numba technicalities.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyclassify.utils">
<span id="submodule-utils"></span><h1>Submodule: utils<a class="headerlink" href="#module-pyclassify.utils" title="Link to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.check_square_matrix">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">check_square_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.check_square_matrix" title="Link to this definition"></a></dt>
<dd><p>Checks if the input matrix is a square matrix of type NumPy ndarray or SciPy sparse matrix.
This is done to ensure that the input matrix <cite>A</cite> is both:
1. Of type <cite>np.ndarray</cite> (NumPy array) or <cite>scipy.sparse.spmatrix</cite> (SciPy sparse matrix).
2. A square matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em><em> or </em><em>cpsp.spmatrix</em>) – The matrix to be checked.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.check_symm_square">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">check_symm_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.check_symm_square" title="Link to this definition"></a></dt>
<dd><p>Checks if the input matrix is a square symmetric matrix of type SciPy sparse matrix.
This is done to ensure that the input matrix <cite>A</cite> is all of the following:
1. A numpy array or a scipy sparse matrix.
2. A square matrix.
3. Symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>sp.spmatrix</em>) – The matrix to be checked.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns or the matrix is not symmetric.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.make_symmetric">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">make_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.make_symmetric" title="Link to this definition"></a></dt>
<dd><p>Ensures the input matrix is symmetric by averaging it with its transpose.</p>
<p>This function first checks if the matrix is square using the <cite>check_square_matrix</cite> function.
Then, it makes the matrix symmetric by averaging it with its transpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em>) – The input square matrix to be made symmetric.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The symmetric version of the input matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or sp.spmatrix</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input matrix is not a NumPy array or SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If the input matrix is not square.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.max_iteration_warning">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">max_iteration_warning</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.max_iteration_warning" title="Link to this definition"></a></dt>
<dd><p>Function to warn the user that the maximum number of iteration has been reached,
hence suggesting that the method did not converge.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.poisson_2d">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">poisson_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.poisson_2d" title="Link to this definition"></a></dt>
<dd><p>Helper function to return an nxn scipy sparse matrix, in particular the one resulting from the discretization of the Laplacian on a 2D grid.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.read_config">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">read_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#pyclassify.utils.read_config" title="Link to this definition"></a></dt>
<dd><p>Reads a YAML configuration file and returns its contents as a dictionary.</p>
<p>This function constructs the absolute path to a YAML file (by appending the ‘.yaml’ extension
to the provided base file name), opens the file, and parses its content using yaml.safe_load.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – The base name of the YAML file (without the ‘.yaml’ extension).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary containing the configuration parameters loaded from the YAML file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="submodule-helpers-secular">
<h1>Submodule: helpers_secular<a class="headerlink" href="#submodule-helpers-secular" title="Link to this heading"></a></h1>
<dl class="py function" id="module-pyclassify.zero_finder">
<dt class="sig sig-object py" id="pyclassify.zero_finder.bisection">
<span class="sig-prename descclassname"><span class="pre">pyclassify.zero_finder.</span></span><span class="sig-name descname"><span class="pre">bisection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.zero_finder.bisection" title="Link to this definition"></a></dt>
<dd><p>Standard bisection method to find a root of the function f in the interval [a, b].</p>
<p>This implementation is used in <cite>compute_outer_zero</cite> to locate the outer eigenvalue.</p>
<p>Parameters:
f (callable): A continuous function for which f(a) * f(b) &lt; 0.
a (float): Left endpoint of the interval.
b (float): Right endpoint of the interval.
tol (float): Tolerance for convergence. The method stops when the interval is smaller than tol or when f(c) is sufficiently small.
max_iter (int): Maximum number of iterations before stopping.</p>
<p>Returns:
float: Approximation of the root within the specified tolerance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.zero_finder.compute_Psi">
<span class="sig-prename descclassname"><span class="pre">pyclassify.zero_finder.</span></span><span class="sig-name descname"><span class="pre">compute_Psi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.zero_finder.compute_Psi" title="Link to this definition"></a></dt>
<dd><p>This function computes the functions Psi1, and Psi2 and their derivative, accordingly to the equation described
by the notes chapter 5-6 contained in the shared folders.
The equation utilized are the equation 5.27, 5.25 and 5.29.
d is assumed to be already a vector whose elements are already sorted.
Inputs:</p>
<blockquote>
<div><p>-i: It is the index of the i-th smallest eigenvalue that is being computed
-v: Rank one correction
-d: Diagonal element of the Diagonal matrix described in equation 5.7
-rho: off diagonal element used for the splitting.</p>
</div></blockquote>
<dl class="simple">
<dt>Output:</dt><dd><p>Psi1:  Lamoba function that returns the value of Psi1 at the point x
Psi2:  Lamoba function that returns the value of Psi2 at the point x
dPsi1: Lamoba function that returns the value of the derivative dPsi1/dx at the point x
dPsi2: Lamoba function that returns the value of the derivative dPsi2/dx at the point x</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.zero_finder.compute_outer_zero">
<span class="sig-prename descclassname"><span class="pre">pyclassify.zero_finder.</span></span><span class="sig-name descname"><span class="pre">compute_outer_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.zero_finder.compute_outer_zero" title="Link to this definition"></a></dt>
<dd><p>Computes the outer eigenvalue (lambda[0] if rho &lt; 0, lambda[n-1] if rho &gt; 0) of a rank-one modified diagonal matrix.</p>
<dl class="simple">
<dt>The secular function  behaves such that:</dt><dd><ul class="simple">
<li><p>If rho &gt; 0, the outer eigenvalue lies in (d[n-1], infty), and f is increasing in this interval.</p></li>
<li><p>If rho &lt; 0, the outer eigenvalue lies in (-infty, d[0]), and f is decreasing in this interval.</p></li>
</ul>
</dd>
</dl>
<p>This function:
1. Determines the direction to search based on the sign of rho.
2. Finds an upper bound (or lower bound for rho &lt; 0) where the secular function changes sign.
3. Uses the bisection method to find the root in the determined interval.</p>
<p>Returns:
float: Approximation of the outer eigenvalue.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.zero_finder.find_root">
<span class="sig-prename descclassname"><span class="pre">pyclassify.zero_finder.</span></span><span class="sig-name descname"><span class="pre">find_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.zero_finder.find_root" title="Link to this definition"></a></dt>
<dd><p>Find the roots of the secular equation contained inside the interval min(d)=d[0] and max(d)=d[-1].
Inputs:</p>
<blockquote>
<div><p>-i: It is the index of the i-th smallest eigenvalue that is being computed
-left_center: boolen variable. True if the left extreme is the center od the new - shifted reference system.
-v: Rank one correction
-d: Diagonal element of the Diagonal matrix described in equation 5.7
-rho: off diagonal element used for the splitting.
-lam_0: initial guess of the i-th root of the secular equation
-tol: absolute or relative tollerence. For lamba value below 1e-6, tols refers to the absolute tolerance (avoiding division by zero). For</p>
<blockquote>
<div><p>lambda value greater than 1e-6, tol is the absolute tolerance.</p>
</div></blockquote>
<p>-maxiter: Maximum number of iteration of the  iterative solver.</p>
</div></blockquote>
<dl class="simple">
<dt>Outputs:</dt><dd><p>-shift + lam_0: i-th smallest eigenvalue
-lam_0: difference between the i-th eigenvalue and the nearest diagonal element.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.zero_finder.secular_solver_python">
<span class="sig-prename descclassname"><span class="pre">pyclassify.zero_finder.</span></span><span class="sig-name descname"><span class="pre">secular_solver_python</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.zero_finder.secular_solver_python" title="Link to this definition"></a></dt>
<dd><p>Computes all the roots of the secular equation.
Inputs:</p>
<blockquote>
<div><p>-v: Rank one correction
-d: Diagonal element of the Diagonal matrix described in equation 5.7
-rho: off diagonal element used for the splitting.</p>
</div></blockquote>
<dl class="simple">
<dt>Outputs:</dt><dd><p>-eig_val: vector of the roots of the secular equation
-index: vector of the index of the center of the shifted frame of reference associated to the i-ith root
-delta: vector of difference between the i-th eigenvalue and the nearest diagonal element.</p>
</dd>
</dl>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">final_project</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">PyClassify Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-pyclassify">Functions:</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.EigenSolver"><code class="docutils literal notranslate"><span class="pre">EigenSolver</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.Lanczos_PRO"><code class="docutils literal notranslate"><span class="pre">Lanczos_PRO()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.eigenvalues_np"><code class="docutils literal notranslate"><span class="pre">eigenvalues_np()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.eigenvalues_sp"><code class="docutils literal notranslate"><span class="pre">eigenvalues_sp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.power_method"><code class="docutils literal notranslate"><span class="pre">power_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.power_method_numba"><code class="docutils literal notranslate"><span class="pre">power_method_numba()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#module-pyclassify.utils">Submodule: utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.check_square_matrix"><code class="docutils literal notranslate"><span class="pre">check_square_matrix()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.check_symm_square"><code class="docutils literal notranslate"><span class="pre">check_symm_square()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.make_symmetric"><code class="docutils literal notranslate"><span class="pre">make_symmetric()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.max_iteration_warning"><code class="docutils literal notranslate"><span class="pre">max_iteration_warning()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.poisson_2d"><code class="docutils literal notranslate"><span class="pre">poisson_2d()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.read_config"><code class="docutils literal notranslate"><span class="pre">read_config()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#submodule-helpers-secular">Submodule: helpers_secular</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.zero_finder.bisection"><code class="docutils literal notranslate"><span class="pre">bisection()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.zero_finder.compute_Psi"><code class="docutils literal notranslate"><span class="pre">compute_Psi()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.zero_finder.compute_outer_zero"><code class="docutils literal notranslate"><span class="pre">compute_outer_zero()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.zero_finder.find_root"><code class="docutils literal notranslate"><span class="pre">find_root()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.zero_finder.secular_solver_python"><code class="docutils literal notranslate"><span class="pre">secular_solver_python()</span></code></a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">final_project documentation</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Gaspare Li Causi, Lorenzo Tomada.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/pyclassify.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>