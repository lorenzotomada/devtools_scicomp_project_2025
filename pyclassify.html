<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PyClassify Module Documentation &#8212; final_project 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=d45e8c67"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="final_project documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pyclassify-module-documentation">
<h1>PyClassify Module Documentation<a class="headerlink" href="#pyclassify-module-documentation" title="Link to this heading"></a></h1>
<p>This module contains all the functions for the PyClassify package.</p>
</section>
<section id="module-pyclassify">
<span id="functions"></span><h1>Functions:<a class="headerlink" href="#module-pyclassify" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pyclassify.EigenSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">EigenSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class solving the eigenvalue problem for a given symmetric matrix.</p>
<p>Two different building blocks are present: Lanczos_PRO (used to transform the matrix to
a tridiagonal one), and another function written in C++. The latter can be either
Eigen_value_calculator (if the user is only interested in the computation of the eigenvalues)
or QR_algorithm, if eigenvectors are needed as well.</p>
<p>We refer the interested reader to their implementation in C++ for further details.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyclassify.EigenSolver.Lanczos_PRO">
<span class="sig-name descname"><span class="pre">Lanczos_PRO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64(1.4901161193847656e-08)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver.Lanczos_PRO" title="Link to this definition"></a></dt>
<dd><p>Perform the Lanczos algorithm for symmetric matrices.</p>
<p>This function computes an orthogonal matrix Q and tridiagonal matrix T such that
.. math:: <cite>A approx Q T Q^T,</cite>
where A is a symmetric matrix. The algorithm is useful for finding a few eigenvalues and eigenvectors
of large symmetric matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A symmetric square matrix of size n x n.</p></li>
<li><p><strong>q</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial vector of size n. Default value is None (a random one is created).</p></li>
<li><p><strong>m</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of eigenvalues to compute. Must be less than or equal to n.
If None, defaults to the size of A.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for orthogonality checks (default is sqrt(machine epsilon)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple (Q, alpha, beta) where:</dt><dd><ul class="simple">
<li><p>Q (np.ndarray): Orthogonal matrix of size n x m.</p></li>
<li><p>alpha (np.ndarray): Vector of size m containing the diagonal elements of the tridiagonal matrix.</p></li>
<li><p>beta (np.ndarray): Vector of size m-1 containing the off-diagonal elements of the tridiagonal matrix.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns or the matrix is not symmetric or it m is
    greater than the size of A.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyclassify.EigenSolver.compute_eigenval">
<span class="sig-name descname"><span class="pre">compute_eigenval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver.compute_eigenval" title="Link to this definition"></a></dt>
<dd><p>Compute (only) the eigenvalues of a symmetric triangular matrix, passed as argument in the form of diagonal and
off-diagonal.</p>
<p>This function relies on the Eigen_value_calculator function, written in C++.
:param diag: Diagonal of the matrix. Default value is None. If no value is passed, the one used</p>
<blockquote>
<div><p>is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>off_diag</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Off-iagonal of the matrix. Default value is None. If no value is passed, the one
used is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an np.array containing the eigenvalues of the matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is a mismatch between the diagonal and off diagonal size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyclassify.EigenSolver.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">off_diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.EigenSolver.eig" title="Link to this definition"></a></dt>
<dd><p>Compute the eigenvalues and eigenvectors of a symmetric triangular matrix, passed as argument in the form of
diagonal and off-diagonal.</p>
<p>This function relies on the QR_algorithm function, written in C++.
:param diag: Diagonal of the matrix. Default value is None. If no value is passed, the one used</p>
<blockquote>
<div><p>is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>off_diag</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Off-iagonal of the matrix. Default value is None. If no value is passed, the one
used is the one resulting from the Lanczos decomposition of the matrix passed to the
constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple containing two arrays, the eigenvalues and the eigenvectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there is a mismatch between the diagonal and off diagonal size.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.eigenvalues_np">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_np</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.eigenvalues_np" title="Link to this definition"></a></dt>
<dd><p>Compute the eigenvalues of a square matrix using NumPy’s <cite>eig</cite> or <cite>eigh</cite> function.</p>
<p>This function checks if the input matrix is square (and is actually a matrix) using
‘check_square_matrix’, and then computes its eigenvalues.</p>
<p>If the matrix is symmetric, it uses <cite>eigh</cite> (which is more efficient for symmetric matrices).
Otherwise, it uses <cite>eig</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigh</cite> for
faster computation. If False, uses <cite>eig</cite> for general matrices
(default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.eigenvalues_sp">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">eigenvalues_sp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.eigenvalues_sp" title="Link to this definition"></a></dt>
<dd><p>Compute the eigenvalues of a sparse matrix using SciPy’s <cite>eigsh</cite> or <cite>eigs</cite> function.</p>
<p>This function checks if the input matrix is square, then computes its eigenvalues using
SciPy’s sparse linear algebra solvers. For symmetric matrices, it uses <cite>eigsh</cite> for
more efficient computation. For non-symmetric matrices, it uses <cite>eigs</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>sp.spmatrix</em>) – A square sparse matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, assumes the matrix is symmetric and uses <cite>eigsh</cite>.
If False, uses <cite>eigs</cite> for general matrices (default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the eigenvalues of the sparse matrix <cite>A</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.power_method">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.power_method" title="Link to this definition"></a></dt>
<dd><p>Compute the dominant eigenvalue of a square matrix using the power method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em><em> or </em><em>cpsp.spmatrix</em>) – A square matrix whose dominant eigenvalue is to be computed.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between iterations
(default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix <cite>A</cite>, computed as the Rayleigh quotient x &#64; A &#64; x.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy/CuPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.power_method_numba">
<span class="sig-prename descclassname"><span class="pre">pyclassify.</span></span><span class="sig-name descname"><span class="pre">power_method_numba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.power_method_numba" title="Link to this definition"></a></dt>
<dd><p>Compute the dominant eigenvalue of a matrix using the power method, with Numba optimization.</p>
<p>This function and applies Numba’s Just-In-Time (JIT) compilation to optimize the performance of the
power method for large matrices.</p>
<p>Remark that numba does not support scipy sparse matrices, so the input matrix must be a NumPy array.
he function is optimized with Numba using the ‘njit’ decorator with nogil and parallel options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>) – A square matrix.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations to perform (default is 500).</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence based on the relative change between
iterations (default is 1e-4).</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Initial guess for the eigenvector. If None, a random vector is generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximated dominant eigenvalue of the matrix A.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the input matrix A is not square. The check is not done using ‘check_square_matrix’
    because of numba technicalities.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyclassify.utils">
<span id="submodule-utils"></span><h1>Submodule: utils<a class="headerlink" href="#module-pyclassify.utils" title="Link to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.check_square_matrix">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">check_square_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.check_square_matrix" title="Link to this definition"></a></dt>
<dd><p>Checks if the input matrix is a square matrix of type NumPy ndarray or SciPy sparse matrix.
This is done to ensure that the input matrix <cite>A</cite> is both:
1. Of type <cite>np.ndarray</cite> (NumPy array) or <cite>scipy.sparse.spmatrix</cite> (SciPy sparse matrix).
2. A square matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em><em> or </em><em>cpsp.spmatrix</em>) – The matrix to be checked.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or a SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.check_symm_square">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">check_symm_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.check_symm_square" title="Link to this definition"></a></dt>
<dd><p>Checks if the input matrix is a square symmetric matrix of type SciPy sparse matrix.
This is done to ensure that the input matrix <cite>A</cite> is all of the following:
1. A numpy array or a scipy sparse matrix.
2. A square matrix.
3. Symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>sp.spmatrix</em>) – The matrix to be checked.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input is not a NumPy array or SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If number of rows != number of columns or the matrix is not symmetric.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.make_symmetric">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">make_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.make_symmetric" title="Link to this definition"></a></dt>
<dd><p>Ensures the input matrix is symmetric by averaging it with its transpose.</p>
<p>This function first checks if the matrix is square using the <cite>check_square_matrix</cite> function.
Then, it makes the matrix symmetric by averaging it with its transpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>np.ndarray</em><em> or </em><em>sp.spmatrix</em>) – The input square matrix to be made symmetric.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The symmetric version of the input matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray or sp.spmatrix</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the input matrix is not a NumPy array or SciPy sparse matrix.</p></li>
<li><p><strong>ValueError</strong> – If the input matrix is not square.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.max_iteration_warning">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">max_iteration_warning</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.max_iteration_warning" title="Link to this definition"></a></dt>
<dd><p>Function to warn the user that the maximum number of iteration has been reached,
hence suggesting that the method did not converge.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.profile_with_cprofile">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">profile_with_cprofile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.utils.profile_with_cprofile" title="Link to this definition"></a></dt>
<dd><p>Function used to profile the code using cProfile.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.utils.read_config">
<span class="sig-prename descclassname"><span class="pre">pyclassify.utils.</span></span><span class="sig-name descname"><span class="pre">read_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#pyclassify.utils.read_config" title="Link to this definition"></a></dt>
<dd><p>Reads a YAML configuration file and returns its contents as a dictionary.</p>
<p>This function constructs the absolute path to a YAML file (by appending the ‘.yaml’ extension
to the provided base file name), opens the file, and parses its content using yaml.safe_load.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – The base name of the YAML file (without the ‘.yaml’ extension).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary containing the configuration parameters loaded from the YAML file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="submodule-helpers-secular">
<h1>Submodule: helpers_secular<a class="headerlink" href="#submodule-helpers-secular" title="Link to this heading"></a></h1>
<dl class="py function" id="module-pyclassify.helpers_secular">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.bisection">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">bisection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.bisection" title="Link to this definition"></a></dt>
<dd><p>Standard bisection method to find a root of the function f in the interval [a, b].</p>
<p>This implementation is used in <cite>compute_outer_zero</cite> to locate the outer eigenvalue.</p>
<p>Parameters:
f (callable): A continuous function for which f(a) * f(b) &lt; 0.
a (float): Left endpoint of the interval.
b (float): Right endpoint of the interval.
tol (float): Tolerance for convergence. The method stops when the interval is smaller than tol or when f(c) is sufficiently small.
max_iter (int): Maximum number of iterations before stopping.</p>
<p>Returns:
float: Approximation of the root within the specified tolerance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.check_is_root">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">check_is_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.check_is_root" title="Link to this definition"></a></dt>
<dd><p>Determines whether x is a root of the function f within a given numerical tolerance.
Written because np.isclose is too restrictive even in cases in which we are indeed close to an eigenvalue.</p>
<p>Parameters:
f (callable): Function to evaluate.
x (float): Point to test as a root.
tol (float): Absolute tolerance for considering f(x) close to zero.</p>
<p>Returns:
bool: True if <a href="#id1"><span class="problematic" id="id2">|f(x)|</span></a> &lt; tol, indicating x is a root within the specified tolerance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.compute_eigenvalues">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">compute_eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.compute_eigenvalues" title="Link to this definition"></a></dt>
<dd><p>Computes all eigenvalues of a rank-one modified diagonal matrix D + rho * v v^T
using the secular equation method.</p>
<p>Parameters:
rho (float): Rank-one update scalar.
d (np.ndarray or scipy.sparse.spmatrix): 1D array of sorted diagonal entries of D.
v (np.ndarray or scipy.sparse.spmatrix): Update vector v in the rank-one perturbation.</p>
<p>Returns:
np.ndarray: Sorted array of all eigenvalues of the perturbed matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.compute_inner_zero">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">compute_inner_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.compute_inner_zero" title="Link to this definition"></a></dt>
<dd><p>Computes the i-th eigenvalue that lies in the interval (d[i], d[i+1]) for a
rank-one modified diagonal matrix using the secular equation.</p>
<p>Parameters:
rho (float): Rank-one update scalar.
d (np.ndarray or scipy.sparse.spmatrix): 1D array of diagonal entries, sorted in ascending order.
v (np.ndarray or scipy.sparse.spmatrix): 1D update vector.
i (int): Index indicating the interval (d[i], d[i+1]) to find the zero in.
tol (float, optional): Tolerance for root-finding. Default is 1e-12.
max_iter (int, optional): Maximum iterations for bisection. Default is 1000.</p>
<p>Returns:
float: The computed inner eigenvalue in the interval (d[i], d[i+1]).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.compute_outer_zero">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">compute_outer_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.compute_outer_zero" title="Link to this definition"></a></dt>
<dd><p>Computes the outer eigenvalue (lambda[0] if rho &lt; 0, lambda[n-1] if rho &gt; 0) of a rank-one modified diagonal matrix.</p>
<dl class="simple">
<dt>The secular function  behaves such that:</dt><dd><ul class="simple">
<li><p>If rho &gt; 0, the outer eigenvalue lies in (d[n-1], infty), and f is increasing in this interval.</p></li>
<li><p>If rho &lt; 0, the outer eigenvalue lies in (-infty, d[0]), and f is decreasing in this interval.</p></li>
</ul>
</dd>
</dl>
<p>This function:
1. Determines the direction to search based on the sign of rho.
2. Finds an upper bound (or lower bound for rho &lt; 0) where the secular function changes sign.
3. Uses the bisection method to find the root in the determined interval.</p>
<p>Parameters:
f (callable): The secular function to find a root of.
rho (float): Scalar rank-one update parameter.
interval_end (float): Either d[0] or d[n-1], depending on the sign of rho.
v (np.ndarray or scipy.sparse.spmatrix): Vector from the rank-one update; used to scale the search step size.
tol (float, optional): Convergence tolerance. Default is 1e-12.
max_iter (int, optional): Maximum number of bisection iterations. Default is 2000.</p>
<p>Returns:
float: Approximation of the outer eigenvalue.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.compute_psi_s">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">compute_psi_s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lambda_guess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_squared</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.compute_psi_s" title="Link to this definition"></a></dt>
<dd><p>Computes partial sums (psi1, psi2) and their derivatives for the secular function
in the i-th interval (d[i], d[i+1]).</p>
<p>Parameters:
lambda_guess (float): Evaluation point for the secular function.
rho (float): Scalar rank-one update parameter.
d (np.ndarray or scipy.sparse.spmatrix): 1D array of diagonal entries.
v_squared (np.ndarray or scipy.sparse.spmatrix): Precomputed elementwise square of the update vector v.
i (int): Index defining the interval (d[i], d[i+1]).</p>
<p>Returns:
tuple: (psi1, psi1’, psi2, psi2’) — the partial secular sums and their derivatives.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.inner_outer_eigs">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">inner_outer_eigs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.inner_outer_eigs" title="Link to this definition"></a></dt>
<dd><p>Splits the eigenvalues into inner eigenvalues and the outer eigenvalue based on the sign of rho.</p>
<p>Parameters:
eigs (np.ndarray or scipy.sparse.spmatrix): Array of eigenvalues, assumed to be sorted.
rho (float): Scalar parameter appearing in the secular function (please refer to the documentation for more detailed info).</p>
<p>Returns:
tuple: A tuple (inner_eigs, outer_eig) where inner_eigs is an array of eigenvalues and outer_eig is a scalar.</p>
<blockquote>
<div><p>If rho &gt; 0, the last eigenvalue is considered outer due to the interlacing property; otherwise, the first is.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.return_secular_f">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">return_secular_f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.return_secular_f" title="Link to this definition"></a></dt>
<dd><p>Constructs the secular function for a rank-one update to a diagonal matrix.</p>
<p>Parameters:
rho (float): Scalar from the rank-one matrix update.
d (np.ndarray or scipy.sparse.spmatrix): 1D array or sparse vector of diagonal entries.
v (np.ndarray or scipy.sparse.spmatrix): 1D array or sparse vector used in the rank-one update.</p>
<p>Returns:
callable:</p>
<blockquote>
<div><p>f(<a href="#id3"><span class="problematic" id="id4">lambda_</span></a>: float) -&gt; float: The secular function evaluated at <a href="#id5"><span class="problematic" id="id6">lambda_</span></a>.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyclassify.helpers_secular.secular_function">
<span class="sig-prename descclassname"><span class="pre">pyclassify.helpers_secular.</span></span><span class="sig-name descname"><span class="pre">secular_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyclassify.helpers_secular.secular_function" title="Link to this definition"></a></dt>
<dd><p>Evaluates the secular function at a given point in the i-th subinterval.</p>
<p>Parameters:
mu (float): Point at which to evaluate the secular function.
rho (float): Scalar from the rank-one matrix update.
d (np.ndarray or scipy.sparse.spmatrix): 1D array or sparse vector of diagonal entries.
v2 (np.ndarray or scipy.sparse.spmatrix): Elementwise square of the update vector v (i.e., v ** 2).
i (int): Index of the subinterval in which mu lies.</p>
<p>Returns:
float: The value of the secular function at mu.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">final_project</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">PyClassify Module Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-pyclassify">Functions:</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.EigenSolver"><code class="docutils literal notranslate"><span class="pre">EigenSolver</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.eigenvalues_np"><code class="docutils literal notranslate"><span class="pre">eigenvalues_np()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.eigenvalues_sp"><code class="docutils literal notranslate"><span class="pre">eigenvalues_sp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.power_method"><code class="docutils literal notranslate"><span class="pre">power_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.power_method_numba"><code class="docutils literal notranslate"><span class="pre">power_method_numba()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#module-pyclassify.utils">Submodule: utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.check_square_matrix"><code class="docutils literal notranslate"><span class="pre">check_square_matrix()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.check_symm_square"><code class="docutils literal notranslate"><span class="pre">check_symm_square()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.make_symmetric"><code class="docutils literal notranslate"><span class="pre">make_symmetric()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.max_iteration_warning"><code class="docutils literal notranslate"><span class="pre">max_iteration_warning()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.profile_with_cprofile"><code class="docutils literal notranslate"><span class="pre">profile_with_cprofile()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.utils.read_config"><code class="docutils literal notranslate"><span class="pre">read_config()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#submodule-helpers-secular">Submodule: helpers_secular</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.bisection"><code class="docutils literal notranslate"><span class="pre">bisection()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.check_is_root"><code class="docutils literal notranslate"><span class="pre">check_is_root()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.compute_eigenvalues"><code class="docutils literal notranslate"><span class="pre">compute_eigenvalues()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.compute_inner_zero"><code class="docutils literal notranslate"><span class="pre">compute_inner_zero()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.compute_outer_zero"><code class="docutils literal notranslate"><span class="pre">compute_outer_zero()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.compute_psi_s"><code class="docutils literal notranslate"><span class="pre">compute_psi_s()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.inner_outer_eigs"><code class="docutils literal notranslate"><span class="pre">inner_outer_eigs()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.return_secular_f"><code class="docutils literal notranslate"><span class="pre">return_secular_f()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyclassify.helpers_secular.secular_function"><code class="docutils literal notranslate"><span class="pre">secular_function()</span></code></a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">final_project documentation</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Gaspare Li Causi, Lorenzo Tomada.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/pyclassify.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>